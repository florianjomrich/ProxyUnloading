//
// Generated file, do not edit! Created by opp_msgc 4.4 from networklayer/xmipv6/MobilityHeader.msg.
//

#ifndef _MOBILITYHEADER_M_H_
#define _MOBILITYHEADER_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "INETDefs.h"
#include "IPv6Address.h"
#include "IPv6Datagram.h" 
#include "IPv6ExtensionHeaders.h" 
#include "KeyMCoABind.h"
// }}



/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum MobOpts{
 * OPTION_PAD1  						=0;
 * OPTION_PADN  						=1;
 * OPTION_BINDING_REFRESH_ADVICE  		=2;
 * OPTION_ALTERNATE_CARE_OF_ADDRESS  	=3;
 * OPTION_NONCES_INDICES  				=4;
 * OPTION_BINDING_AUTHORIZATION_DATA  	=5;
 * OPTION_HOME_ADDRESS  				=201;
 * 
 * OPTION_BINDING_IDENTIFIER_MOBILITY  =135 ;   
 *     
 * }
 * </pre>
 */
enum MobOpts {
    OPTION_PAD1 = 0,
    OPTION_PADN = 1,
    OPTION_BINDING_REFRESH_ADVICE = 2,
    OPTION_ALTERNATE_CARE_OF_ADDRESS = 3,
    OPTION_NONCES_INDICES = 4,
    OPTION_BINDING_AUTHORIZATION_DATA = 5,
    OPTION_HOME_ADDRESS = 201,
    OPTION_BINDING_IDENTIFIER_MOBILITY = 135
};

/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum MobOptsPayloadLen{
 *     LEN_MOBOPTS_HEADER_FIELDS	= 	 2; 
 *  	LEN_BINDING_REFRESH_ADVICE 	=    4; 
 *  	LEN_NONCE_INDICES			=    4;
 *  	LEN_BINDING_AUTHORIZATION_DATA =   14; 
 *  	LEN_BID_NO_COA					=    6;   
 *  	LEN_BID_WITH_COA				= 	22;   
 * }
 * </pre>
 */
enum MobOptsPayloadLen {
    LEN_MOBOPTS_HEADER_FIELDS = 2,
    LEN_BINDING_REFRESH_ADVICE = 4,
    LEN_NONCE_INDICES = 4,
    LEN_BINDING_AUTHORIZATION_DATA = 14,
    LEN_BID_NO_COA = 6,
    LEN_BID_WITH_COA = 22
};

/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum MobilityHeaderType
 * {
 * 
 *     BINDING_REFRESH_REQUEST = 0;
 *     HOME_TEST_INIT = 1;
 *     CARE_OF_TEST_INIT = 2;
 *     HOME_TEST = 3;
 *     CARE_OF_TEST = 4;
 *     BINDING_UPDATE = 5;
 *     BINDING_ACKNOWLEDGEMENT = 6;
 *     BINDING_ERROR = 7;
 * }
 * </pre>
 */
enum MobilityHeaderType {
    BINDING_REFRESH_REQUEST = 0,
    HOME_TEST_INIT = 1,
    CARE_OF_TEST_INIT = 2,
    HOME_TEST = 3,
    CARE_OF_TEST = 4,
    BINDING_UPDATE = 5,
    BINDING_ACKNOWLEDGEMENT = 6,
    BINDING_ERROR = 7
};

/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum BAStatus
 * {
 * 
 *     BINDING_UPDATE_ACCEPTED = 0;
 *     BU_ACCEPT_BUT_DISCOVER_PREFIX = 1;
 *     REASON_UNSPECIFIED = 128;
 *     ADMINISTRATIVELY_PROHIBITED = 129;
 *     INSUFFICIENT_RESOURCES = 130;
 *     HOME_REGISTRATION_NOT_SUPPORTED = 131;
 *     NOT_HOME_SUBNET = 132;
 *     NOT_HA_FOR_THIS_MN = 133;
 *     DAD_FAILED = 134;
 *     SEQUENCE_NUMBER_OUT_OF_WINDOW = 135;
 *     EXPIRED_HOME_NONCE_INDEX = 136;
 *     EXPIRED_CARE_OF_NONCE_INDEX = 137;
 *     EXPIRED_NONCES = 138;
 *     REGISTRATION_TYPE_CHANGE_DISALLOWED = 139;
 *     
 *     
 *     
 * 	MCOA_NOTCOMPLETE 				     			=	4;
 * 	MCOA_RETURNHOME_WO_NDP 							=	5;
 * 	MCOA_MALFORMED 									=	164;
 * 	MCOA_NON_MCOA_BINDING_EXISTS 					=	165;
 * 	MCOA_UNKOWN_COA 								=	167;
 * 	MCOA_PROHIBITED 								=	166;
 * 	MCOA_BULK_REGISTRATION_PROHIBITED 				=	168;
 * 	MCOA_SIMULTANEOUS_HOME_AND_FOREIGN_PROHIBITED 	=	169;
 *     
 *     
 * }
 * </pre>
 */
enum BAStatus {
    BINDING_UPDATE_ACCEPTED = 0,
    BU_ACCEPT_BUT_DISCOVER_PREFIX = 1,
    REASON_UNSPECIFIED = 128,
    ADMINISTRATIVELY_PROHIBITED = 129,
    INSUFFICIENT_RESOURCES = 130,
    HOME_REGISTRATION_NOT_SUPPORTED = 131,
    NOT_HOME_SUBNET = 132,
    NOT_HA_FOR_THIS_MN = 133,
    DAD_FAILED = 134,
    SEQUENCE_NUMBER_OUT_OF_WINDOW = 135,
    EXPIRED_HOME_NONCE_INDEX = 136,
    EXPIRED_CARE_OF_NONCE_INDEX = 137,
    EXPIRED_NONCES = 138,
    REGISTRATION_TYPE_CHANGE_DISALLOWED = 139,
    MCOA_NOTCOMPLETE = 4,
    MCOA_RETURNHOME_WO_NDP = 5,
    MCOA_MALFORMED = 164,
    MCOA_NON_MCOA_BINDING_EXISTS = 165,
    MCOA_UNKOWN_COA = 167,
    MCOA_PROHIBITED = 166,
    MCOA_BULK_REGISTRATION_PROHIBITED = 168,
    MCOA_SIMULTANEOUS_HOME_AND_FOREIGN_PROHIBITED = 169
};

/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum BEStatus
 * {
 * 
 *     UNKNOWN_BINDING_FOR_HOME_ADDRESS_DEST_OPTION = 1;
 *     UNKNOWN_MH_TYPE = 2; 
 * }
 * </pre>
 */
enum BEStatus {
    UNKNOWN_BINDING_FOR_HOME_ADDRESS_DEST_OPTION = 1,
    UNKNOWN_MH_TYPE = 2
};

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * class MobOption{
 *     
 * 	unsigned int mobOptionType enum(MobOpts);
 * 	unsigned int mobOptionLength;
 * 	
 * 	int payloadLength; 
 * 	    
 * }
 * </pre>
 */
class MobOption : public ::cObject
{
  protected:
    unsigned int mobOptionType_var;
    unsigned int mobOptionLength_var;
    int payloadLength_var;

  private:
    void copy(const MobOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobOption&);

  public:
    MobOption();
    MobOption(const MobOption& other);
    virtual ~MobOption();
    MobOption& operator=(const MobOption& other);
    virtual MobOption *dup() const {return new MobOption(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getMobOptionType() const;
    virtual void setMobOptionType(unsigned int mobOptionType);
    virtual unsigned int getMobOptionLength() const;
    virtual void setMobOptionLength(unsigned int mobOptionLength);
    virtual int getPayloadLength() const;
    virtual void setPayloadLength(int payloadLength);
};

inline void doPacking(cCommBuffer *b, MobOption& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * class  MobOption_Binding_RefreshAdvice extends MobOption {
 *     
 *  	unsigned int  refreshInterval;   
 *  	
 *  
 * }
 * </pre>
 */
class MobOption_Binding_RefreshAdvice : public ::MobOption
{
  protected:
    unsigned int refreshInterval_var;

  private:
    void copy(const MobOption_Binding_RefreshAdvice& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobOption_Binding_RefreshAdvice&);

  public:
    MobOption_Binding_RefreshAdvice();
    MobOption_Binding_RefreshAdvice(const MobOption_Binding_RefreshAdvice& other);
    virtual ~MobOption_Binding_RefreshAdvice();
    MobOption_Binding_RefreshAdvice& operator=(const MobOption_Binding_RefreshAdvice& other);
    virtual MobOption_Binding_RefreshAdvice *dup() const {return new MobOption_Binding_RefreshAdvice(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getRefreshInterval() const;
    virtual void setRefreshInterval(unsigned int refreshInterval);
};

inline void doPacking(cCommBuffer *b, MobOption_Binding_RefreshAdvice& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobOption_Binding_RefreshAdvice& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * class MobOption_Nonce_Indices extends MobOption {
 *     
 *  	int home_nonce_index;
 *  	int care_of_nonce_index;
 *  	   
 * }
 * </pre>
 */
class MobOption_Nonce_Indices : public ::MobOption
{
  protected:
    int home_nonce_index_var;
    int care_of_nonce_index_var;

  private:
    void copy(const MobOption_Nonce_Indices& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobOption_Nonce_Indices&);

  public:
    MobOption_Nonce_Indices();
    MobOption_Nonce_Indices(const MobOption_Nonce_Indices& other);
    virtual ~MobOption_Nonce_Indices();
    MobOption_Nonce_Indices& operator=(const MobOption_Nonce_Indices& other);
    virtual MobOption_Nonce_Indices *dup() const {return new MobOption_Nonce_Indices(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHome_nonce_index() const;
    virtual void setHome_nonce_index(int home_nonce_index);
    virtual int getCare_of_nonce_index() const;
    virtual void setCare_of_nonce_index(int care_of_nonce_index);
};

inline void doPacking(cCommBuffer *b, MobOption_Nonce_Indices& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobOption_Nonce_Indices& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * class  MobOption_Binding_AuthorizationData extends MobOption{
 * 	
 * 	int authenticator; 
 * 	
 * 	
 * }
 * </pre>
 */
class MobOption_Binding_AuthorizationData : public ::MobOption
{
  protected:
    int authenticator_var;

  private:
    void copy(const MobOption_Binding_AuthorizationData& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobOption_Binding_AuthorizationData&);

  public:
    MobOption_Binding_AuthorizationData();
    MobOption_Binding_AuthorizationData(const MobOption_Binding_AuthorizationData& other);
    virtual ~MobOption_Binding_AuthorizationData();
    MobOption_Binding_AuthorizationData& operator=(const MobOption_Binding_AuthorizationData& other);
    virtual MobOption_Binding_AuthorizationData *dup() const {return new MobOption_Binding_AuthorizationData(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getAuthenticator() const;
    virtual void setAuthenticator(int authenticator);
};

inline void doPacking(cCommBuffer *b, MobOption_Binding_AuthorizationData& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobOption_Binding_AuthorizationData& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * class  MobOption_Binding_Identifier_Mobility extends MobOption
 * {
 *  
 * 
 * 	
 * 	unsigned int Reserved;
 * 	unsigned int Status;
 * 	bool HFlag;
 * 	
 * 	KeyMCoABind kMCoA;
 * 	
 * 	
 * }
 * </pre>
 */
class MobOption_Binding_Identifier_Mobility : public ::MobOption
{
  protected:
    unsigned int Reserved_var;
    unsigned int Status_var;
    bool HFlag_var;
    KeyMCoABind kMCoA_var;

  private:
    void copy(const MobOption_Binding_Identifier_Mobility& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobOption_Binding_Identifier_Mobility&);

  public:
    MobOption_Binding_Identifier_Mobility();
    MobOption_Binding_Identifier_Mobility(const MobOption_Binding_Identifier_Mobility& other);
    virtual ~MobOption_Binding_Identifier_Mobility();
    MobOption_Binding_Identifier_Mobility& operator=(const MobOption_Binding_Identifier_Mobility& other);
    virtual MobOption_Binding_Identifier_Mobility *dup() const {return new MobOption_Binding_Identifier_Mobility(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getReserved() const;
    virtual void setReserved(unsigned int Reserved);
    virtual unsigned int getStatus() const;
    virtual void setStatus(unsigned int Status);
    virtual bool getHFlag() const;
    virtual void setHFlag(bool HFlag);
    virtual KeyMCoABind& getKMCoA();
    virtual const KeyMCoABind& getKMCoA() const {return const_cast<MobOption_Binding_Identifier_Mobility*>(this)->getKMCoA();}
    virtual void setKMCoA(const KeyMCoABind& kMCoA);
};

inline void doPacking(cCommBuffer *b, MobOption_Binding_Identifier_Mobility& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobOption_Binding_Identifier_Mobility& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * class MobilityBIDOptions{
 * 
 * 	MobOption_Binding_Identifier_Mobility  mobOpts[];
 * }
 * </pre>
 */
class MobilityBIDOptions : public ::cObject
{
  protected:
    MobOption_Binding_Identifier_Mobility *mobOpts_var; // array ptr
    unsigned int mobOpts_arraysize;

  private:
    void copy(const MobilityBIDOptions& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobilityBIDOptions&);

  public:
    MobilityBIDOptions();
    MobilityBIDOptions(const MobilityBIDOptions& other);
    virtual ~MobilityBIDOptions();
    MobilityBIDOptions& operator=(const MobilityBIDOptions& other);
    virtual MobilityBIDOptions *dup() const {return new MobilityBIDOptions(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setMobOptsArraySize(unsigned int size);
    virtual unsigned int getMobOptsArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobOpts(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobOpts(unsigned int k) const {return const_cast<MobilityBIDOptions*>(this)->getMobOpts(k);}
    virtual void setMobOpts(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobOpts);
};

inline void doPacking(cCommBuffer *b, MobilityBIDOptions& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobilityBIDOptions& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet MobilityHeader 
 * {
 *     int mobilityHeaderType enum(MobilityHeaderType);
 * }
 * </pre>
 */
class MobilityHeader : public ::cPacket
{
  protected:
    int mobilityHeaderType_var;

  private:
    void copy(const MobilityHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobilityHeader&);

  public:
    MobilityHeader(const char *name=NULL, int kind=0);
    MobilityHeader(const MobilityHeader& other);
    virtual ~MobilityHeader();
    MobilityHeader& operator=(const MobilityHeader& other);
    virtual MobilityHeader *dup() const {return new MobilityHeader(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMobilityHeaderType() const;
    virtual void setMobilityHeaderType(int mobilityHeaderType);
};

inline void doPacking(cCommBuffer *b, MobilityHeader& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobilityHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingUpdate extends MobilityHeader
 * {
 *     unsigned int lifetime;
 *     unsigned int sequence;
 *     bool ackFlag;				
 *     bool homeRegistrationFlag;		
 *     bool linkLocalAddressCompatibilityFlag;	
 *     bool keyManagementFlag = false;		
 *     
 *     
 *     
 *     bool mapHMIPv6Flag;					
 *     bool mobRouterFlag;					
 *     bool proxyRegistrationFlag;			
 *     bool forceUDPencap;					
 *     bool tunnelGREflag;					
 *     bool overwriteFlag;					
 *     
 *     
 *     IPv6Address homeAddressMN;		
 * 
 *     
 *     int bindingAuthorizationData = 0; 
 *     
 *     
 *     
 *  
 *  	MobOption_Binding_AuthorizationData mobBindingAuthorization; 
 *  	
 *  	MobOption_Binding_Identifier_Mobility mobBIDmobility[]; 
 *    
 * }
 * </pre>
 */
class BindingUpdate : public ::MobilityHeader
{
  protected:
    unsigned int lifetime_var;
    unsigned int sequence_var;
    bool ackFlag_var;
    bool homeRegistrationFlag_var;
    bool linkLocalAddressCompatibilityFlag_var;
    bool keyManagementFlag_var;
    bool mapHMIPv6Flag_var;
    bool mobRouterFlag_var;
    bool proxyRegistrationFlag_var;
    bool forceUDPencap_var;
    bool tunnelGREflag_var;
    bool overwriteFlag_var;
    IPv6Address homeAddressMN_var;
    int bindingAuthorizationData_var;
    MobOption_Binding_AuthorizationData mobBindingAuthorization_var;
    MobOption_Binding_Identifier_Mobility *mobBIDmobility_var; // array ptr
    unsigned int mobBIDmobility_arraysize;

  private:
    void copy(const BindingUpdate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingUpdate&);

  public:
    BindingUpdate(const char *name=NULL, int kind=0);
    BindingUpdate(const BindingUpdate& other);
    virtual ~BindingUpdate();
    BindingUpdate& operator=(const BindingUpdate& other);
    virtual BindingUpdate *dup() const {return new BindingUpdate(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getLifetime() const;
    virtual void setLifetime(unsigned int lifetime);
    virtual unsigned int getSequence() const;
    virtual void setSequence(unsigned int sequence);
    virtual bool getAckFlag() const;
    virtual void setAckFlag(bool ackFlag);
    virtual bool getHomeRegistrationFlag() const;
    virtual void setHomeRegistrationFlag(bool homeRegistrationFlag);
    virtual bool getLinkLocalAddressCompatibilityFlag() const;
    virtual void setLinkLocalAddressCompatibilityFlag(bool linkLocalAddressCompatibilityFlag);
    virtual bool getKeyManagementFlag() const;
    virtual void setKeyManagementFlag(bool keyManagementFlag);
    virtual bool getMapHMIPv6Flag() const;
    virtual void setMapHMIPv6Flag(bool mapHMIPv6Flag);
    virtual bool getMobRouterFlag() const;
    virtual void setMobRouterFlag(bool mobRouterFlag);
    virtual bool getProxyRegistrationFlag() const;
    virtual void setProxyRegistrationFlag(bool proxyRegistrationFlag);
    virtual bool getForceUDPencap() const;
    virtual void setForceUDPencap(bool forceUDPencap);
    virtual bool getTunnelGREflag() const;
    virtual void setTunnelGREflag(bool tunnelGREflag);
    virtual bool getOverwriteFlag() const;
    virtual void setOverwriteFlag(bool overwriteFlag);
    virtual IPv6Address& getHomeAddressMN();
    virtual const IPv6Address& getHomeAddressMN() const {return const_cast<BindingUpdate*>(this)->getHomeAddressMN();}
    virtual void setHomeAddressMN(const IPv6Address& homeAddressMN);
    virtual int getBindingAuthorizationData() const;
    virtual void setBindingAuthorizationData(int bindingAuthorizationData);
    virtual MobOption_Binding_AuthorizationData& getMobBindingAuthorization();
    virtual const MobOption_Binding_AuthorizationData& getMobBindingAuthorization() const {return const_cast<BindingUpdate*>(this)->getMobBindingAuthorization();}
    virtual void setMobBindingAuthorization(const MobOption_Binding_AuthorizationData& mobBindingAuthorization);
    virtual void setMobBIDmobilityArraySize(unsigned int size);
    virtual unsigned int getMobBIDmobilityArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k) const {return const_cast<BindingUpdate*>(this)->getMobBIDmobility(k);}
    virtual void setMobBIDmobility(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobBIDmobility);
};

inline void doPacking(cCommBuffer *b, BindingUpdate& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingUpdate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingAcknowledgement extends MobilityHeader
 * {
 *     int status enum(BAStatus);
 *     unsigned int sequenceNumber;
 *     unsigned int lifetime;
 *     bool keyManagementFlag = false;
 * 	
 * 
 *     
 *     int bindingAuthorizationData = 0; 
 *     
 *     
 *     
 *     MobOption_Binding_RefreshAdvice mobBindingRefreshAdvice;
 *     
 *     MobOption_Binding_AuthorizationData mobBindingAuthorization;
 *     
 *     MobOption_Binding_Identifier_Mobility mobBIDmobility[]; 
 * }
 * </pre>
 */
class BindingAcknowledgement : public ::MobilityHeader
{
  protected:
    int status_var;
    unsigned int sequenceNumber_var;
    unsigned int lifetime_var;
    bool keyManagementFlag_var;
    int bindingAuthorizationData_var;
    MobOption_Binding_RefreshAdvice mobBindingRefreshAdvice_var;
    MobOption_Binding_AuthorizationData mobBindingAuthorization_var;
    MobOption_Binding_Identifier_Mobility *mobBIDmobility_var; // array ptr
    unsigned int mobBIDmobility_arraysize;

  private:
    void copy(const BindingAcknowledgement& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingAcknowledgement&);

  public:
    BindingAcknowledgement(const char *name=NULL, int kind=0);
    BindingAcknowledgement(const BindingAcknowledgement& other);
    virtual ~BindingAcknowledgement();
    BindingAcknowledgement& operator=(const BindingAcknowledgement& other);
    virtual BindingAcknowledgement *dup() const {return new BindingAcknowledgement(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getStatus() const;
    virtual void setStatus(int status);
    virtual unsigned int getSequenceNumber() const;
    virtual void setSequenceNumber(unsigned int sequenceNumber);
    virtual unsigned int getLifetime() const;
    virtual void setLifetime(unsigned int lifetime);
    virtual bool getKeyManagementFlag() const;
    virtual void setKeyManagementFlag(bool keyManagementFlag);
    virtual int getBindingAuthorizationData() const;
    virtual void setBindingAuthorizationData(int bindingAuthorizationData);
    virtual MobOption_Binding_RefreshAdvice& getMobBindingRefreshAdvice();
    virtual const MobOption_Binding_RefreshAdvice& getMobBindingRefreshAdvice() const {return const_cast<BindingAcknowledgement*>(this)->getMobBindingRefreshAdvice();}
    virtual void setMobBindingRefreshAdvice(const MobOption_Binding_RefreshAdvice& mobBindingRefreshAdvice);
    virtual MobOption_Binding_AuthorizationData& getMobBindingAuthorization();
    virtual const MobOption_Binding_AuthorizationData& getMobBindingAuthorization() const {return const_cast<BindingAcknowledgement*>(this)->getMobBindingAuthorization();}
    virtual void setMobBindingAuthorization(const MobOption_Binding_AuthorizationData& mobBindingAuthorization);
    virtual void setMobBIDmobilityArraySize(unsigned int size);
    virtual unsigned int getMobBIDmobilityArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k) const {return const_cast<BindingAcknowledgement*>(this)->getMobBIDmobility(k);}
    virtual void setMobBIDmobility(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobBIDmobility);
};

inline void doPacking(cCommBuffer *b, BindingAcknowledgement& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingAcknowledgement& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingError extends MobilityHeader
 * {
 *     int status enum(BEStatus);
 *     IPv6Address homeAddress;
 * 	
 * 
 * }
 * </pre>
 */
class BindingError : public ::MobilityHeader
{
  protected:
    int status_var;
    IPv6Address homeAddress_var;

  private:
    void copy(const BindingError& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingError&);

  public:
    BindingError(const char *name=NULL, int kind=0);
    BindingError(const BindingError& other);
    virtual ~BindingError();
    BindingError& operator=(const BindingError& other);
    virtual BindingError *dup() const {return new BindingError(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getStatus() const;
    virtual void setStatus(int status);
    virtual IPv6Address& getHomeAddress();
    virtual const IPv6Address& getHomeAddress() const {return const_cast<BindingError*>(this)->getHomeAddress();}
    virtual void setHomeAddress(const IPv6Address& homeAddress);
};

inline void doPacking(cCommBuffer *b, BindingError& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingError& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet HomeTestInit extends MobilityHeader
 * {
 *     unsigned int homeInitCookie;
 *     
 *     MobOption_Binding_Identifier_Mobility mobBIDmobility[];
 *     
 * }
 * </pre>
 */
class HomeTestInit : public ::MobilityHeader
{
  protected:
    unsigned int homeInitCookie_var;
    MobOption_Binding_Identifier_Mobility *mobBIDmobility_var; // array ptr
    unsigned int mobBIDmobility_arraysize;

  private:
    void copy(const HomeTestInit& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HomeTestInit&);

  public:
    HomeTestInit(const char *name=NULL, int kind=0);
    HomeTestInit(const HomeTestInit& other);
    virtual ~HomeTestInit();
    HomeTestInit& operator=(const HomeTestInit& other);
    virtual HomeTestInit *dup() const {return new HomeTestInit(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getHomeInitCookie() const;
    virtual void setHomeInitCookie(unsigned int homeInitCookie);
    virtual void setMobBIDmobilityArraySize(unsigned int size);
    virtual unsigned int getMobBIDmobilityArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k) const {return const_cast<HomeTestInit*>(this)->getMobBIDmobility(k);}
    virtual void setMobBIDmobility(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobBIDmobility);
};

inline void doPacking(cCommBuffer *b, HomeTestInit& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HomeTestInit& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet HomeTest extends MobilityHeader
 * {
 *     unsigned int homeInitCookie;
 *     unsigned int homeKeyGenToken;
 * 	
 * 	
 * 	MobOption_Binding_Identifier_Mobility mobBIDmobility[];
 * 	
 * }
 * </pre>
 */
class HomeTest : public ::MobilityHeader
{
  protected:
    unsigned int homeInitCookie_var;
    unsigned int homeKeyGenToken_var;
    MobOption_Binding_Identifier_Mobility *mobBIDmobility_var; // array ptr
    unsigned int mobBIDmobility_arraysize;

  private:
    void copy(const HomeTest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HomeTest&);

  public:
    HomeTest(const char *name=NULL, int kind=0);
    HomeTest(const HomeTest& other);
    virtual ~HomeTest();
    HomeTest& operator=(const HomeTest& other);
    virtual HomeTest *dup() const {return new HomeTest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getHomeInitCookie() const;
    virtual void setHomeInitCookie(unsigned int homeInitCookie);
    virtual unsigned int getHomeKeyGenToken() const;
    virtual void setHomeKeyGenToken(unsigned int homeKeyGenToken);
    virtual void setMobBIDmobilityArraySize(unsigned int size);
    virtual unsigned int getMobBIDmobilityArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k) const {return const_cast<HomeTest*>(this)->getMobBIDmobility(k);}
    virtual void setMobBIDmobility(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobBIDmobility);
};

inline void doPacking(cCommBuffer *b, HomeTest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HomeTest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet CareOfTestInit extends MobilityHeader
 * {
 *     unsigned int careOfInitCookie;
 *     
 *     
 *     MobOption_Binding_Identifier_Mobility mobBIDmobility[]; 
 * }
 * </pre>
 */
class CareOfTestInit : public ::MobilityHeader
{
  protected:
    unsigned int careOfInitCookie_var;
    MobOption_Binding_Identifier_Mobility *mobBIDmobility_var; // array ptr
    unsigned int mobBIDmobility_arraysize;

  private:
    void copy(const CareOfTestInit& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CareOfTestInit&);

  public:
    CareOfTestInit(const char *name=NULL, int kind=0);
    CareOfTestInit(const CareOfTestInit& other);
    virtual ~CareOfTestInit();
    CareOfTestInit& operator=(const CareOfTestInit& other);
    virtual CareOfTestInit *dup() const {return new CareOfTestInit(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getCareOfInitCookie() const;
    virtual void setCareOfInitCookie(unsigned int careOfInitCookie);
    virtual void setMobBIDmobilityArraySize(unsigned int size);
    virtual unsigned int getMobBIDmobilityArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k) const {return const_cast<CareOfTestInit*>(this)->getMobBIDmobility(k);}
    virtual void setMobBIDmobility(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobBIDmobility);
};

inline void doPacking(cCommBuffer *b, CareOfTestInit& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CareOfTestInit& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet CareOfTest extends MobilityHeader
 * {
 *     unsigned int careOfInitCookie;
 *     unsigned int careOfKeyGenToken;
 * 	
 * 	
 * 	MobOption_Binding_Identifier_Mobility mobBIDmobility[]; 
 * }
 * </pre>
 */
class CareOfTest : public ::MobilityHeader
{
  protected:
    unsigned int careOfInitCookie_var;
    unsigned int careOfKeyGenToken_var;
    MobOption_Binding_Identifier_Mobility *mobBIDmobility_var; // array ptr
    unsigned int mobBIDmobility_arraysize;

  private:
    void copy(const CareOfTest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CareOfTest&);

  public:
    CareOfTest(const char *name=NULL, int kind=0);
    CareOfTest(const CareOfTest& other);
    virtual ~CareOfTest();
    CareOfTest& operator=(const CareOfTest& other);
    virtual CareOfTest *dup() const {return new CareOfTest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getCareOfInitCookie() const;
    virtual void setCareOfInitCookie(unsigned int careOfInitCookie);
    virtual unsigned int getCareOfKeyGenToken() const;
    virtual void setCareOfKeyGenToken(unsigned int careOfKeyGenToken);
    virtual void setMobBIDmobilityArraySize(unsigned int size);
    virtual unsigned int getMobBIDmobilityArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k) const {return const_cast<CareOfTest*>(this)->getMobBIDmobility(k);}
    virtual void setMobBIDmobility(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobBIDmobility);
};

inline void doPacking(cCommBuffer *b, CareOfTest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CareOfTest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingRefreshRequest extends MobilityHeader
 * {
 *     
 *     
 *     MobOption_Binding_Identifier_Mobility mobBIDmobility[]; 
 * }
 * </pre>
 */
class BindingRefreshRequest : public ::MobilityHeader
{
  protected:
    MobOption_Binding_Identifier_Mobility *mobBIDmobility_var; // array ptr
    unsigned int mobBIDmobility_arraysize;

  private:
    void copy(const BindingRefreshRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingRefreshRequest&);

  public:
    BindingRefreshRequest(const char *name=NULL, int kind=0);
    BindingRefreshRequest(const BindingRefreshRequest& other);
    virtual ~BindingRefreshRequest();
    BindingRefreshRequest& operator=(const BindingRefreshRequest& other);
    virtual BindingRefreshRequest *dup() const {return new BindingRefreshRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setMobBIDmobilityArraySize(unsigned int size);
    virtual unsigned int getMobBIDmobilityArraySize() const;
    virtual MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k);
    virtual const MobOption_Binding_Identifier_Mobility& getMobBIDmobility(unsigned int k) const {return const_cast<BindingRefreshRequest*>(this)->getMobBIDmobility(k);}
    virtual void setMobBIDmobility(unsigned int k, const MobOption_Binding_Identifier_Mobility& mobBIDmobility);
};

inline void doPacking(cCommBuffer *b, BindingRefreshRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingRefreshRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet HomeAddressOption extends IPv6DestinationOptionsHeader
 * {
 *     @customize(true);
 *     IPv6Address homeAddress;
 * }
 * </pre>
 *
 * HomeAddressOption_Base is only useful if it gets subclassed, and HomeAddressOption is derived from it.
 * The minimum code to be written for HomeAddressOption is the following:
 *
 * <pre>
 * class HomeAddressOption : public HomeAddressOption_Base
 * {
 *   private:
 *     void copy(const HomeAddressOption& other) { ... }

 *   public:
 *     HomeAddressOption() : HomeAddressOption_Base() {}
 *     HomeAddressOption(const HomeAddressOption& other) : HomeAddressOption_Base(other) {copy(other);}
 *     HomeAddressOption& operator=(const HomeAddressOption& other) {if (this==&other) return *this; HomeAddressOption_Base::operator=(other); copy(other); return *this;}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from HomeAddressOption_Base
 * };
 * </pre>
 */
class HomeAddressOption_Base : public ::IPv6DestinationOptionsHeader
{
  protected:
    IPv6Address homeAddress_var;

  private:
    void copy(const HomeAddressOption_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HomeAddressOption_Base&);
    // make constructors protected to avoid instantiation
    HomeAddressOption_Base();
    HomeAddressOption_Base(const HomeAddressOption_Base& other);
    // make assignment operator protected to force the user override it
    HomeAddressOption_Base& operator=(const HomeAddressOption_Base& other);

  public:
    virtual ~HomeAddressOption_Base();
    virtual HomeAddressOption_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class HomeAddressOption");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPv6Address& getHomeAddress();
    virtual const IPv6Address& getHomeAddress() const {return const_cast<HomeAddressOption_Base*>(this)->getHomeAddress();}
    virtual void setHomeAddress(const IPv6Address& homeAddress);
};


#endif // _MOBILITYHEADER_M_H_
